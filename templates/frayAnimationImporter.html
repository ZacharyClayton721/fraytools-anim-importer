<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Fray Animation Importer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Assistant:wght@200..800&family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&family=Rubik:ital,wght@0,300..900;1,300..900&display=swap"
      rel="stylesheet"
    />

    <style>
      body {
        background: #ebe9e9;
        margin: 0;
        padding: 0;
      }

      .header {
        font-family: 'Roboto Condensed', sans-serif;
        font-weight: 400;
        text-align: center;
        font-size: 40px;
        margin: 10px 0px 10px 0px;
      }

      .subheader {
        font-family: 'Assistant', sans-serif;
        font-weight: 400;
        font-size: 24px;
        text-align: center;
        margin: 10px 0px 10px 0px;
        position: relative;
        overflow: hidden;
      }

      .projectPromptContainer {
        display: flex;
        flex-direction: row;
        justify-content: center;
      }

      .projectPrompt {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border: solid black 3px;
        border-radius: 5px;
        width: 50%;
      }

      .projectPromptMessage {
        font-family: 'Assistant', sans-serif;
        font-weight: 400;
        font-size: 20px;
        text-align: center;
        margin: 10px 0px 10px 0px;
      }

      .projectPromptFiles {
        font-family: 'Assistant', sans-serif;
        font-weight: 400;
        font-size: 16px;
        text-align: center;
        margin: 10px 0px 10px 0px;
      }

      .projectPromptButton {
        font-family: 'Assistant', sans-serif;
        font-weight: 400;
        font-size: 16px;
        text-align: center;
        margin: 10px 0px 10px 0px;
      }

      .hide {
        display: none;
      }

      .dropdownContainer {
        width: 60%;
        margin: auto;
        font-family: 'Assistant', sans-serif;
      }

      .dropdown {
        background-color: #fff;
        border: 2px solid #444;
        border-radius: 6px;
        margin: 10px 0;
        overflow: hidden;
      }

      .dropdownHeader {
        background-color: #ccc;
        padding: 12px;
        cursor: pointer;
        font-weight: bold;
      }

      .dropdownContent {
        display: none;
        padding: 10px;
        border-top: 1px solid #444;
        background-color: #f9f9f9;
      }

      .dropdownContent ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
      }

      .dropdownContent li {
        padding: 10px;
        cursor: pointer;
        border-bottom: 1px solid #ddd;
        transition: background-color 0.2s;
      }

      .dropdownContent li:nth-child(odd) {
        background-color: #f1f1f1;
      }

      .dropdownContent li:nth-child(even) {
        background-color: #ffffff;
      }

      .dropdownContent li:hover {
        background-color: #e0e0e0;
      }

      .popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }

      .popupContent {
        background-color: white;
        padding: 30px;
        border-radius: 12px;
        position: relative;
        width: 300px;
        text-align: center;
        font-family: 'Assistant', sans-serif;
      }

      .closeBtn {
        position: absolute;
        top: 10px;
        left: 10px;
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
      }

      .hidden {
        display: none;
      }

      #renderBtn {
        padding: 10px 20px;
        margin-top: 20px;
        font-size: 16px;
        background-color: #4caf50;
        border: none;
        color: white;
        border-radius: 6px;
        cursor: pointer;
      }

      #renderBtn:hover {
        background-color: #45a049;
      }

      .preview {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }

      .download {
        padding: 10px 20px;
        margin-top: 20px;
        font-size: 16px;
        background-color: #4caf50;
        border: none;
        color: white;
        border-radius: 6px;
        cursor: pointer;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        background-color: #fff;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      }
      th,
      td {
        padding: 12px 16px;
        border-bottom: 1px solid #ddd;
        text-align: left;
      }

      td {
        font-family: 'Assistant', sans-serif;
      }
      th {
        font-size: 16px;
        background-color: #f0f0f0;
        font-family: 'Roboto Condensed', sans-serif;
        font-weight: bold;
      }
      audio {
        width: 200px;
      }
      tr:hover {
        background-color: #f1f1f1;
      }

      input[type='text'] {
        width: 100%;
        padding: 6px;
        box-sizing: border-box;
        font-size: 16px;
        font-family: 'Assistant', sans-serif;
      }

      .audioContainer {
        margin: 40px 40px;
      }

      .copy-btn {
        background: none;
        border: none;
        color: #000000;
        cursor: pointer;
        text-decoration: underline;
        font-size: 16px;
        padding: 0;
        font-family: 'Assistant', sans-serif;
      }
      .copy-btn:hover {
        color: #191919;
      }

      .animated-container {
        position: relative;
        display: inline-block;
        height: 1em;
      }

      #animated-text {
        position: absolute;
        white-space: nowrap;
        opacity: 0;
        transform: translateX(50px);
        transition:
          opacity 0.5s ease,
          transform 0.5s ease;
      }

      #animated-text.enter {
        opacity: 1;
        transform: translateX(0);
      }

      .anim-box {
        border: 1px solid #ccc;
        overflow: hidden;
      }

      .anim-header {
        margin: 0;
        padding: 10px;
        background: #eee;
        cursor: pointer;
        transition: background 0.2s;
      }

      .anim-header:hover {
        background: #ddd;
      }

      .anim-content {
        padding: 10px;
        background: #fafafa;
      }

      .anim-gif {
        max-width: 100%;
        margin-top: 10px;
        border: 1px solid #ccc;
      }

      .anim-header {
        cursor: pointer;
        padding: 8px;
        background: #f0f0f0;
        border-bottom: 1px solid #ccc;
      }

      .anim-name-input {
        font-size: 1em;
      }
    </style>
  </head>
  <body>
    <h1 class="header">Fray Animation Importer</h1>
    <h2 class="subheader">Import Animations Into a Project!</h2>
    <h2 class="subheader">
      Currently Supports:
      <span class="animated-container"><span id="animated-text"></span></span>
    </h2>
    <div id="projectPromptView" class="projectPromptContainer">
      <div class="projectPrompt">
        <div id="projectPromptTemplate" class="hidden">
          <p>Choose Template</p>
          <select id="selectedTemplate">
            <option value="fraymakers-super-template">super</option>
            <option value="characterTemplate">Character Template</option>
          </select>
          <input type="text" id="projectName" />
          <button class="projectPromptButton" onclick="importCharacter(event)">Import Character</button>
        </div>

        <div id="projectPromptInital">
          <p class="projectPromptMessage">Upload Project Files</p>
          <label for="folderInput">Sprite Folder</label>
          <input type="file" id="projectSprites" webkitdirectory multiple onchange="uploadSprites(event)" />
          <br />
          <label for="airFile">Air File</label>
          <input type="file" id="airFile" onchange="uploadAirFile(event)" />
          <br />
          <label for="cnsFiles">Cns Files</label>
          <input type="file" id="cnsFile" multiple accept=".cns" onchange="uploadCnsFiles(event)" />
        </div>
      </div>
      <br />
    </div>
    <br />

    <div id="animNameDisplay"></div>

    <script>
      var spritesUploaded = false;
      var airUploaded = false;

      async function uploadSprites(event) {
        const files = event.target.files;

        var chunkSize = 100;

        const filesArray = Array.from(files); // Convert FileList to an array

        let chunkedFiles = [];

        // Split the files into chunks
        for (let i = 0; i < filesArray.length; i += chunkSize) {
          chunkedFiles.push(filesArray.slice(i, i + chunkSize));
        }

        for (let chunk of chunkedFiles) {
          const formData = new FormData();

          // Add all files in the current chunk to the formData
          chunk.forEach((file) => {
            formData.append('files', file);
            formData.append('file_paths', file.webkitRelativePath); // Add the relative path as a separate field
          });

          // Include the total file count in the request (so the server knows when to return the final result)
          formData.append('total_files', files.length);

          try {
            const response = await fetch('/uploadSprites', {
              method: 'POST',
              body: formData,
            });

            const result = await response.json();

            if (result['status'] == 'Upload Complete') {
              console.log('Yes sir');
              spritesUploaded = true;

              if (spritesUploaded == true && airUploaded == true) {
                document.getElementById('projectPromptInital').classList.add('hidden');
                document.getElementById('projectPromptTemplate').classList.remove('hidden');
              }
            }
          } catch (err) {
            console.error('Upload failed:', err);
          }
        }
      }

      async function uploadAirFile(event) {
        const files = event.target.files;

        const filesArray = Array.from(files);

        const formData = new FormData();

        formData.append('file', filesArray[0]);
        const response = await fetch('/uploadAir', {
          method: 'POST',
          body: formData,
        });

        const result = await response.json();

        if (result['status'] == 'Upload Complete') {
          animationNames = result['anim names'];
          const animHolder = document.getElementById('animNameDisplay');

          for (let an of animationNames) {
            // Main container
            const box = document.createElement('div');
            box.className = 'anim-box';

            // Header that acts as toggle
            const header = document.createElement('h3');
            header.className = 'anim-header';
            header.dataset.airAnim = an;

            // Create editable label span
            const nameSpan = document.createElement('span');
            nameSpan.textContent = an;
            nameSpan.className = 'anim-name';
            header.appendChild(nameSpan);

            // Create input for editing
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = an;
            nameInput.className = 'anim-name-input';
            nameInput.style.display = 'none';
            header.appendChild(nameInput);

            // Expandable content (initially hidden)
            const content = document.createElement('div');
            content.className = 'anim-content';
            content.style.display = 'none'; // Hidden by default

            // Placeholder for extra options (customize as needed)
            const options = document.createElement('div');
            options.innerHTML = `<p>Options for ${an}</p>`; // Add real options here

            // Placeholder for GIF
            const gif = document.createElement('img');
            gif.alt = `${an} preview`;
            gif.className = 'anim-gif';

            // Only load gif when expanded
            let gifLoaded = false;

            header.addEventListener('click', async (event) => {
              const isVisible = content.style.display === 'block';
              content.style.display = isVisible ? 'none' : 'block';

              console.log(event.target);

              if (!gifLoaded && !isVisible) {
                try {
                  // Show loading state (optional)
                  gif.alt = 'Loading...';

                  // POST request to generate the GIF
                  const response = await fetch('/generateAnimPreview', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                      animation: event.target.dataset.airAnim,
                    }), // Send the header name
                  });

                  if (!response.ok) throw new Error('Failed to generate GIF');

                  // Assuming server responds with URL or base64 data
                  const data = await response.json();

                  // Assuming `data.preview` is either a URL path or a base64 data URI
                  gif.src = `data:image/webp;base64,${data['preview']}`;
                  gif.alt = `${event.target.dataset.airAnim} preview`;
                  gifLoaded = true;
                } catch (err) {
                  gif.alt = 'Failed to load GIF';
                  console.error(err);
                }
              }
            });

            // Show input on span click
            nameSpan.addEventListener('click', (e) => {
              e.stopPropagation(); // Prevent accordion toggle
              nameSpan.style.display = 'none';
              nameInput.style.display = 'inline-block';
              nameInput.focus();
            });

            // Save name on blur or Enter key
            nameInput.addEventListener('blur', () => {
              nameSpan.textContent = nameInput.value;
              nameInput.style.display = 'none';
              nameSpan.style.display = 'inline-block';
            });

            nameInput.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                nameInput.blur(); // Triggers blur event to save
              }
            });

            content.appendChild(options);
            content.appendChild(gif);
            box.appendChild(header);
            box.appendChild(content);
            animHolder.appendChild(box);
          }

          airUploaded = true;

          if (spritesUploaded == true && airUploaded == true) {
            document.getElementById('projectPromptInital').classList.add('hidden');
            document.getElementById('projectPromptTemplate').classList.remove('hidden');
          }
        }
      }

      async function uploadCnsFiles(event) {
        const files = event.target.files;
        const formData = new FormData();

        for (const file of files) {
          formData.append('files', file); // MUST match Flask: getlist("files")
        }

        const response = await fetch('/uploadCns', {
          method: 'POST',
          body: formData,
        });

        const result = await response.json();

        if (result.status === 'Upload Complete') {
          console.log('CNS Upload');
        } else {
          console.error('Upload failed:', result);
        }
      }

      async function importCharacter(event) {
        var selectedTemplate = document.getElementById('selectedTemplate').value;
        var projectName = document.getElementById('projectName').value;

        const response = await fetch('/importCharacter', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            template: selectedTemplate,
            projectName: projectName,
          }),
        });

        if (!response.ok) {
          console.error('Failed to download file.');
          return;
        }

        // Get filename from Content-Disposition header
        let filename = 'project_files.zip'; // fallback name
        const disposition = response.headers.get('Content-Disposition');

        if (disposition && disposition.includes('attachment')) {
          const match = disposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
          if (match && match[1]) {
            filename = match[1].replace(/['"]/g, '');
          }
        }

        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = filename; // match Flask's download_name
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
      }

      /* Animate the Currently Supports Text */
      const words = ['Folder', 'Mugen', 'Aseprite', 'GIF'];
      let index = 0;
      const textElement = document.getElementById('animated-text');

      function animateText() {
        // Remove animation class
        textElement.classList.remove('enter');

        // Wait a moment before setting new text
        setTimeout(() => {
          textElement.textContent = words[index];
          textElement.classList.add('enter');
          index = (index + 1) % words.length;
        }, 100); // short delay to reset the animation
      }

      // Initial call and loop every 2 seconds
      animateText();
      setInterval(animateText, 4000);
    </script>
  </body>
</html>
